{"version":3,"sources":["../../src/internal/createImageOptions.ts"],"names":["allowedImageProperties","multiplex","options","keys","Object","values","map","key","value","product","entries","result","forEach","i","normalizeProperty","parseFloat","normalizeOutputOptions","args","normalize","val","Array","isArray","length","undefined","reduce","out","v","createImageOptions","meta","outputOptions","newMeta","base","config","item","preset"],"mappings":"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","sourcesContent":["import sharp from 'sharp';\n\nimport {OutputOptions, ImageOptions} from '../types';\nimport {cartesianProduct} from './cartesianProduct';\n\nconst allowedImageProperties = [\n  'name',\n  'scale',\n  'blur',\n  'width',\n  'height',\n  'mode',\n  'format',\n  'inline',\n] as const;\n\nfunction multiplex<T extends Record<string, any>>(\n  options: {[V in keyof T]: V[]},\n): T[] {\n  const keys: (keyof T)[] = Object.keys(options);\n  const values = keys.map((key) => {\n    const value = options[key];\n    return value;\n  });\n  const product = cartesianProduct<{[V in keyof T]: V[]}[keyof T][number]>(\n    values,\n  );\n  return product.map((entries) => {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    const result: T = {} as T;\n    keys.forEach((key, i) => {\n      const value = entries[i] as T[keyof T];\n      result[key] = value;\n    });\n    return result;\n  });\n}\n\nconst normalizeProperty = (key: string, value: any): any => {\n  switch (key) {\n    case 'scale':\n    case 'blur':\n    case 'width':\n    case 'height':\n      return parseFloat(value);\n    default:\n      return value;\n  }\n};\n\nexport const normalizeOutputOptions = (\n  options: OutputOptions,\n  ...args: any[]\n): OutputOptions => {\n  const normalize = (key: string, val: unknown): any => {\n    if (typeof val === 'function') {\n      return normalize(key, val(...args));\n    } else if (Array.isArray(val)) {\n      if (val.length === 0) {\n        return undefined;\n      }\n      return val.reduce((out, v) => {\n        if (typeof v !== 'undefined') {\n          return [...out, normalizeProperty(key, v)];\n        }\n        return out;\n      }, []);\n    } else if (typeof val !== 'undefined') {\n      return [normalizeProperty(key, val)];\n    }\n    return undefined;\n  };\n  const keys = Object.keys(options) as (keyof OutputOptions)[];\n  const result: OutputOptions = {};\n  keys.forEach((key) => {\n    const out = normalize(key, options[key]);\n    if (typeof out !== 'undefined') {\n      result[key] = out;\n    }\n  });\n  return result;\n};\n\nexport const createImageOptions = (\n  meta: sharp.Metadata,\n  outputOptions: OutputOptions,\n): Array<ImageOptions> => {\n  let newMeta = meta;\n  if (typeof outputOptions.meta === 'function') {\n    newMeta = outputOptions.meta(meta);\n  }\n  const base = normalizeOutputOptions(outputOptions, newMeta);\n  const config: Record<string, any> = {};\n  allowedImageProperties.forEach((key) => {\n    if (typeof base[key] !== 'undefined') {\n      config[key] = base[key];\n    }\n  });\n  const out = multiplex(config);\n  out.forEach((item) => {\n    // NOTE: Can copy any non-multiplexed values here.\n    if (typeof outputOptions.preset === 'string') {\n      item.preset = outputOptions.preset;\n    }\n  });\n  return out;\n};\n"],"file":"createImageOptions.js"}