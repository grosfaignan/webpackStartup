"use strict";

var _sharp = _interopRequireDefault(require("sharp"));

var _loaderUtils = _interopRequireDefault(require("loader-utils"));

var R = _interopRequireWildcard(require("runtypes"));

var _createImageObject = _interopRequireDefault(require("./internal/createImageObject"));

var _transformImage = _interopRequireDefault(require("./internal/transformImage"));

var _getImageMetadata = require("./internal/getImageMetadata");

var _Cache = require("./internal/Cache");

var _createImageOptions = require("./internal/createImageOptions");

var _toArray = require("./internal/toArray");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const doTransform = async (image, meta, imageOptions, loader, cache) => {
  const metaCacheKey = ['meta', loader.resourcePath, imageOptions];
  const bufferCacheKey = ['data', loader.resourcePath, imageOptions];
  const [cachedData, cachedInfo] = await Promise.all([cache.readBuffer(bufferCacheKey), cache.readJson(metaCacheKey)]);

  if (cachedData !== undefined && cachedInfo !== undefined) {
    return {
      data: cachedData,
      info: cachedInfo
    };
  }

  const result = await (0, _transformImage.default)(image, meta, imageOptions).toBuffer({
    resolveWithObject: true
  });
  await cache.writeBuffer(bufferCacheKey, result.data);
  await cache.writeJson(metaCacheKey, result.info);
  return result;
};

const processImage = async (input, image, meta, imageOptions, context, loader, cache) => {
  const {
    data,
    info
  } = await doTransform(image, meta, imageOptions, loader, cache);
  const asset = (0, _createImageObject.default)(input, info, imageOptions, context, loader);
  return {
    asset,
    data,
    info
  };
};

const getDataUrl = result => {
  if (!Buffer.isBuffer(result.data)) {
    throw new TypeError('Must provide `image` with `inline` on.');
  }

  if (typeof result.asset.type !== 'string') {
    throw new TypeError('Unable to determine image type.');
  }

  return JSON.stringify(`data:${result.asset.type};base64,${result.data.toString('base64')}`);
};

const Preset = R.Partial({});
const GlobalQuery = R.Partial({
  cacheDirectory: R.Union(R.String, R.Boolean),
  context: R.String,
  defaultOutputs: R.Array(R.String),
  presets: R.Dictionary(Preset),
  emitFile: R.Boolean,
  name: R.String,
  meta: R.Function
});
const LocalQuery = R.Partial({
  outputs: R.Array(R.Union(R.String, R.Partial({})))
});

const runLoader = async function (loaderContext, input) {
  var _globalQuery$context, _globalQuery$presets;

  const globalQuery = GlobalQuery.check(_loaderUtils.default.getOptions(loaderContext));
  const localQuery = LocalQuery.check(typeof loaderContext.resourceQuery === 'string' && loaderContext.resourceQuery.length > 0 ? _loaderUtils.default.parseQuery(loaderContext.resourceQuery) : {});
  const image = (0, _sharp.default)(input);
  const context = (_globalQuery$context = globalQuery.context) !== null && _globalQuery$context !== void 0 ? _globalQuery$context : loaderContext.rootContext;
  const cache = new _Cache.Cache({
    cacheDir: globalQuery.cacheDirectory
  });
  const meta = await (0, _getImageMetadata.getImageMetadata)(image, loaderContext.resourcePath, cache);
  const scaleMatch = /@([0-9]+)x/.exec(loaderContext.resourcePath);
  const nextMeta = { ...meta
  };

  if (scaleMatch !== null) {
    nextMeta.scale = parseInt(scaleMatch[1], 10);

    if (typeof nextMeta.width !== 'number' || typeof nextMeta.height !== 'number') {
      throw new TypeError();
    }

    nextMeta.width /= nextMeta.scale;
    nextMeta.height /= nextMeta.scale;
  }

  const presetNames = Object.keys((_globalQuery$presets = globalQuery.presets) !== null && _globalQuery$presets !== void 0 ? _globalQuery$presets : {});
  const defaultOutputs = (0, _toArray.toArray)(globalQuery.defaultOutputs, presetNames);
  const outputs = (0, _toArray.toArray)(localQuery.outputs, defaultOutputs);

  const requirePreset = name => {
    if (globalQuery.presets !== undefined && name in globalQuery.presets) {
      return {
        name: globalQuery.name,
        meta: globalQuery.meta,
        ...globalQuery.presets[name],
        preset: name
      };
    }

    return null;
  };

  const optionsList = outputs.reduce((prev, output) => {
    if (typeof output === 'string') {
      const preset = requirePreset(output);

      if (preset !== null) {
        return [...prev, ...(0, _createImageOptions.createImageOptions)(nextMeta, preset)];
      }

      return prev;
    } else if (typeof output === 'object') {
      const preset = typeof output.preset === 'string' ? requirePreset(output.preset) : null;
      return [...prev, ...(0, _createImageOptions.createImageOptions)(nextMeta, { ...preset,
        ...output
      })];
    }

    return prev;
  }, []);
  const results = await Promise.all(optionsList.map(async imageOptions => {
    return await processImage(input, image, nextMeta, imageOptions, context, loaderContext, cache);
  }));
  return [`var assets = ${JSON.stringify(results.map(({
    asset
  }) => asset))};`, ...optionsList.map((options, i) => {
    if (options.inline !== true && globalQuery.emitFile !== false) {
      loaderContext.emitFile(results[i].asset.name, results[i].data, null);
    }

    return `assets[${i}].url = ` + (options.inline === true ? `${getDataUrl(results[i])};` : `__webpack_public_path__ + assets[${i}].name;`);
  }), 'module.exports = assets;'].join('\n');
};

module.exports = function (input) {
  // This means that, for a given query string, the loader will only be
  // run once. No point in barfing out the same image over and over.
  this.cacheable();
  const callback = this.async();

  if (typeof callback !== 'function') {
    throw new TypeError();
  }

  runLoader(this, input).then(code => callback(null, code), callback);
}; // Force buffers since sharp doesn't want strings.


module.exports.raw = true;
//# sourceMappingURL=sharp.js.map