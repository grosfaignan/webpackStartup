{"version":3,"sources":["../src/sharp.ts"],"names":["doTransform","image","meta","imageOptions","loader","cache","metaCacheKey","resourcePath","bufferCacheKey","cachedData","cachedInfo","Promise","all","readBuffer","readJson","undefined","data","info","result","toBuffer","resolveWithObject","writeBuffer","writeJson","processImage","input","context","asset","getDataUrl","Buffer","isBuffer","TypeError","type","JSON","stringify","toString","Preset","R","Partial","GlobalQuery","cacheDirectory","Union","String","Boolean","defaultOutputs","Array","presets","Dictionary","emitFile","name","Function","LocalQuery","outputs","runLoader","loaderContext","globalQuery","check","loaderUtils","getOptions","localQuery","resourceQuery","length","parseQuery","rootContext","Cache","cacheDir","scaleMatch","exec","nextMeta","scale","parseInt","width","height","presetNames","Object","keys","requirePreset","preset","optionsList","reduce","prev","output","results","map","options","i","inline","join","module","exports","cacheable","callback","async","then","code","raw"],"mappings":"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","sourcesContent":["import sharp from 'sharp';\nimport loaderUtils from 'loader-utils';\nimport * as webpack from 'webpack';\nimport * as R from 'runtypes';\n\nimport createImageObject from './internal/createImageObject';\nimport transformImage from './internal/transformImage';\nimport {getImageMetadata} from './internal/getImageMetadata';\nimport {Cache} from './internal/Cache';\n\nimport {OutputOptions, ImageOptions, ImageObject} from './types';\nimport {createImageOptions} from './internal/createImageOptions';\nimport {toArray} from './internal/toArray';\n\nconst doTransform = async (\n  image: sharp.Sharp,\n  meta: sharp.Metadata,\n  imageOptions: ImageOptions,\n  loader: webpack.loader.LoaderContext,\n  cache: Cache,\n): Promise<{data: Buffer; info: sharp.OutputInfo}> => {\n  const metaCacheKey = ['meta', loader.resourcePath, imageOptions];\n  const bufferCacheKey = ['data', loader.resourcePath, imageOptions];\n  const [cachedData, cachedInfo] = await Promise.all([\n    cache.readBuffer(bufferCacheKey),\n    cache.readJson(metaCacheKey),\n  ]);\n  if (cachedData !== undefined && cachedInfo !== undefined) {\n    return {data: cachedData, info: cachedInfo as sharp.OutputInfo};\n  }\n  const result = await transformImage(image, meta, imageOptions).toBuffer({\n    resolveWithObject: true,\n  });\n  await cache.writeBuffer(bufferCacheKey, result.data);\n  await cache.writeJson(metaCacheKey, result.info);\n  return result;\n};\n\ninterface Result {\n  asset: ImageObject;\n  data: Buffer;\n  info: sharp.OutputInfo;\n}\n\nconst processImage = async (\n  input: Buffer,\n  image: sharp.Sharp,\n  meta: sharp.Metadata,\n  imageOptions: ImageOptions,\n  context: string,\n  loader: webpack.loader.LoaderContext,\n  cache: Cache,\n): Promise<Result> => {\n  const {data, info} = await doTransform(\n    image,\n    meta,\n    imageOptions,\n    loader,\n    cache,\n  );\n  const asset = createImageObject(input, info, imageOptions, context, loader);\n  return {asset, data, info};\n};\n\nconst getDataUrl = (result: Result): string => {\n  if (!Buffer.isBuffer(result.data)) {\n    throw new TypeError('Must provide `image` with `inline` on.');\n  }\n  if (typeof result.asset.type !== 'string') {\n    throw new TypeError('Unable to determine image type.');\n  }\n  return JSON.stringify(\n    `data:${result.asset.type};base64,${result.data.toString('base64')}`,\n  );\n};\n\nconst Preset = R.Partial({});\n\nconst GlobalQuery = R.Partial({\n  cacheDirectory: R.Union(R.String, R.Boolean),\n  context: R.String,\n  defaultOutputs: R.Array(R.String),\n  presets: R.Dictionary(Preset),\n  emitFile: R.Boolean,\n  name: R.String,\n  meta: R.Function,\n});\n\nconst LocalQuery = R.Partial({\n  outputs: R.Array(R.Union(R.String, R.Partial({}))),\n});\n\nconst runLoader = async function (\n  loaderContext: webpack.loader.LoaderContext,\n  input: Buffer,\n): Promise<string> {\n  const globalQuery = GlobalQuery.check(loaderUtils.getOptions(loaderContext));\n  const localQuery = LocalQuery.check(\n    typeof loaderContext.resourceQuery === 'string' &&\n      loaderContext.resourceQuery.length > 0\n      ? loaderUtils.parseQuery(loaderContext.resourceQuery)\n      : {},\n  );\n\n  const image: sharp.Sharp = sharp(input);\n\n  const context = globalQuery.context ?? loaderContext.rootContext;\n\n  const cache = new Cache({cacheDir: globalQuery.cacheDirectory});\n\n  const meta = await getImageMetadata(image, loaderContext.resourcePath, cache);\n  const scaleMatch = /@([0-9]+)x/.exec(loaderContext.resourcePath);\n  const nextMeta: {\n    scale?: number;\n  } & typeof meta = {...meta};\n  if (scaleMatch !== null) {\n    nextMeta.scale = parseInt(scaleMatch[1], 10);\n    if (\n      typeof nextMeta.width !== 'number' ||\n      typeof nextMeta.height !== 'number'\n    ) {\n      throw new TypeError();\n    }\n    nextMeta.width /= nextMeta.scale;\n    nextMeta.height /= nextMeta.scale;\n  }\n  const presetNames = Object.keys(globalQuery.presets ?? {});\n  const defaultOutputs = toArray(globalQuery.defaultOutputs, presetNames);\n  const outputs = toArray<string | OutputOptions>(\n    localQuery.outputs,\n    defaultOutputs,\n  );\n\n  const requirePreset = (name: string): null | any => {\n    if (globalQuery.presets !== undefined && name in globalQuery.presets) {\n      return {\n        name: globalQuery.name,\n        meta: globalQuery.meta,\n        ...globalQuery.presets[name],\n        preset: name,\n      };\n    }\n    return null;\n  };\n\n  const optionsList: ImageOptions[] = outputs.reduce(\n    (prev: ImageOptions[], output: string | OutputOptions): ImageOptions[] => {\n      if (typeof output === 'string') {\n        const preset = requirePreset(output);\n        if (preset !== null) {\n          return [...prev, ...createImageOptions(nextMeta, preset)];\n        }\n        return prev;\n      } else if (typeof output === 'object') {\n        const preset =\n          typeof output.preset === 'string'\n            ? requirePreset(output.preset)\n            : null;\n        return [\n          ...prev,\n          ...createImageOptions(nextMeta, {\n            ...preset,\n            ...output,\n          }),\n        ];\n      }\n      return prev;\n    },\n    [],\n  );\n  const results = await Promise.all(\n    optionsList.map(\n      async (imageOptions): Promise<Result> => {\n        return await processImage(\n          input,\n          image,\n          nextMeta,\n          imageOptions,\n          context,\n          loaderContext,\n          cache,\n        );\n      },\n    ),\n  );\n  return [\n    `var assets = ${JSON.stringify(results.map(({asset}) => asset))};`,\n    ...optionsList.map((options, i) => {\n      if (options.inline !== true && globalQuery.emitFile !== false) {\n        loaderContext.emitFile(results[i].asset.name, results[i].data, null);\n      }\n      return (\n        `assets[${i}].url = ` +\n        (options.inline === true\n          ? `${getDataUrl(results[i])};`\n          : `__webpack_public_path__ + assets[${i}].name;`)\n      );\n    }),\n    'module.exports = assets;',\n  ].join('\\n');\n};\n\nmodule.exports = function (this: webpack.loader.LoaderContext, input: Buffer) {\n  // This means that, for a given query string, the loader will only be\n  // run once. No point in barfing out the same image over and over.\n  this.cacheable();\n  const callback = this.async();\n  if (typeof callback !== 'function') {\n    throw new TypeError();\n  }\n  runLoader(this, input).then((code) => callback(null, code), callback);\n};\n// Force buffers since sharp doesn't want strings.\nmodule.exports.raw = true;\n"],"file":"sharp.js"}